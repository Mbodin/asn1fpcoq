
  The C loops are derived forms.
  \begin{lstlisting}[language=Coq]
Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).

  \end{lstlisting}

  \end{frame}


\begin{frame}[fragile]{Examples}

    \begin{lstlisting}[language=Coq]

      (* int s = 1 *)
      (Sset _s (Econst_int (Int.repr 1) tint))

      (* return s *)
      (Sreturn (Some (Etempvar _s tint)))

      (*  *)
      (Sifthenelse (Etempvar _s tint) Sskip Sbreak)

  \end{lstlisting}

  \end{frame}


\begin{frame}

  Limitations

  Partial correctness (safety? liveness?)

  \end{frame}

  \section{Operational semantics: bigstep}
  \begin{frame}

     Our goal is to prove that programs written in C light behave as intented. To do this we need to formalize the notion of meaning of a C light program. We do this using what is called operational semantics. We start from assigning primitive values to constants and then compositionally assign values to expressions and statement.

  \end{frame}

  \begin{frame}
    A CompCert C value is either\footnote{This is a common semantics used for all intermediate languages of CompCert, such as C minor etc.}:
    \begin{itemize}

\item a machine integer;
\item a floating-point number;
\item a pointer: a pair of a memory address and an integer offset with respect
  to this address;
\item the \texttt{Vundef} value denoting an arbitrary bit pattern, such as the
  value of an uninitialized variable.
 \end{itemize}
