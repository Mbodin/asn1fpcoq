\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usepackage{listings}

\input{listings-coq}

\title{Proving C program correct using C light operational semantics}
\date{ }

\begin{document}

\maketitle

\begin{frame}{Outline}
\begin{enumerate}
\item Formal verification - quick intro (high-level)
\item Coq mini intro 

\item Approach
\begin{itemize}   
\item Particular approach we consider: reasoning about C programs in Coq
\item Base PL concepts mini intro: syntax, AST, semantics.
\end{itemize}{}
\item Toy example: strlen Informal specification (man page)
\begin{itemize}

\item Formal specification of strlen (relational)
\item Simple implementation in C
\item From C program to AST using clightgen
\item Semantics of C program semantics and its equivalence to specification
\item Undefined behaviours in C and guarding against them
\end{itemize}{}
\item Conclusions
\end{enumerate} 
\end{frame}{}

% do the first two sections in the end, maybe ask boys
\section{Formal verification - quick intro}
\begin{frame}
 
   We want to have high assurance that our code works as intended. One of the methods is formal verification. It is a broad term that includes many techniques. Here I will talk about deductive verification. This means we want to produce a formal proof that our code works as intended. What does it mean exactly and how do we do it?
  
   On one hand we have C implementation of some function,
   on the other hand we have our ideas about what it supposed to do -- its specification. To formally verify some function we need to:
  \begin{enumerate}
  \item Write it's specification in some formal language  
  \item Write the implementation in the same formal language
  \item Formalize the notion of ``meeting the specification'' (partial correctness, total correctness)
  \item Prove that your implementation meets the specification
  \end{enumerate}
\end{frame}



\begin{frame}
CompCert example
\end{frame}
\begin{frame}{Coq intro}
\end{frame}

\section{Approach}

\begin{frame}
Explain what was done before: disadvantages and advantages of purely functional approach (Illya)
\end{frame}


 
\begin{frame}
\begin{itemize}
\item reason about the actual implementation
\item parse C code into an abstract syntax tree using C light generator of CompCert (not verified)
\item reason about the C light program using operational semantics
\end{itemize}
\end{frame}
\subsection{Base PL concepts mini intro: syntax, AST, semantics.}

\begin{frame}
  Concrete vs Abstract syntax

  We write a C program in concrete C syntax, which is designed to be used by a parser (a + b).
  Abstract syntax tree: nodes are constructors, leaves are atoms (plus (a,b)).
  todo: more on AST

  Deep embedding of C light to Coq := the abstract syntax is defined as inductive datatypes
  
\end{frame}
\begin{frame}{C light syntax}
\begin{description}
\item[types]
\end{description}

\end{frame}

\begin{frame}[fragile]{Expressions of C light}
  \begin{lstlisting}[language=Coq]
Inductive expr : Type :=
| Econst_int: int -> type -> expr  (* integer literal *)    
| Econst_float: float -> type -> expr (* double float literal *)
| Econst_single: float32 -> type -> expr (* single float *)
| Econst_long: int64 -> type -> expr (* long integer literal *)
| Evar: ident -> type -> expr (* variable *)
| Etempvar: ident -> type -> expr (* temporary variable *)
| Ederef: expr -> type -> expr (* pointer dereference (*) *)
| Eaddrof: expr -> type -> expr (* address-of operator (&) *)
| Eunop: unary_operation -> expr -> type -> expr
(* unary operation *)
| Ebinop: binary_operation -> expr -> expr -> type -> expr
(* binary operation *)
| Ecast: expr -> type -> expr   (* type cast *)
| Efield: expr -> ident -> type -> expr
(* access to a member of a struct or union *)
| Esizeof: type -> type -> expr (* size of a type *)
| Ealignof: type -> type -> expr. (* alignment of a type *)
\end{lstlisting}


\end{frame}


    

\begin{frame}[fragile]{Examples}

  \begin{lstlisting}[language=Coq]
    (* 0 *)
    (Econst_int Int.zero tint) 

    (* 0 + 1 *)
    (Ebinop Oadd (Econst_int Int.zero tint)
    (Econst_int (Int.repr 1) tint) (tint))

    (* int *p *)
    (Etempvar _p (tptr tint)) 
    
    (* (*p) *)
    (Ederef (Etempvar _p (tptr tint)) tint)


  \end{lstlisting}
  


\end{frame}


\begin{frame}

Note that in C light all expressions are {\bf pure}. Variable assignements and function calls are statements.
    
\end{frame}

\begin{frame}[fragile]{Statements}

  \begin{lstlisting}[language=Coq]
Inductive statement : Type :=
| Sskip : statement (* do nothing *)
| Sassign : expr -> expr -> statement
(* assignment lvalue = rvalue *)
| Sset : ident -> expr -> statement
(* assignment tempvar = rvalue *)
| Scall: option ident -> expr -> list expr -> statement
| Sbuiltin: option ident -> external_function -> typelist -> list expr -> statement
(* builtin invocation *)
| Ssequence : statement -> statement -> statement
| Sifthenelse : expr  -> statement -> statement -> statement
| Sloop: statement -> statement -> statement (* infinite loop *)
| Sbreak : statement
| Scontinue : statement
| Sreturn : option expr -> statement
| Sswitch : expr -> labeled_statements -> statement
| Slabel : label -> statement -> statement
| Sgoto : label -> statement

  \end{lstlisting}
  


\end{frame}



\begin{frame}[fragile]{Statements}

  \begin{lstlisting}[language=Coq]
    
Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).

  \end{lstlisting}
  


\end{frame}


\begin{frame}[fragile]{Examples}

  \begin{lstlisting}[language=Coq]
     (* int s = 1; *)
      (Sset _s (Econst_int (Int.repr 1) tint))

      (* return s; *)
      (Sreturn (Some (Etempvar _s tint)))

      (* while (s) {s = s - 1;} *)
      (Swhile (Etempvar _s tint) 
      (Ssequence  
        (Sset _s (Ebinop Osub (Etempvar _input tint)
                (Econst_int (Int.repr 1) tint) tint))))


  \end{lstlisting}
  


\end{frame}

\begin{frame}{Unsupported features}
  \begin{itemize}
  \item `extern` declaration of arrays
\item structs and unions cannot be passed by value
\item  type qualifiers (`const`, `volatile`, `restrict`) are erased at parsing
\item within expressions no side-effects nor function calls (meaning all C light expressions always terminate and are pure)
\item statements: in `for(s1, a, s2)` s1 and s2 are statements, that do not terminate by break
\item `extern` functions are only declared and not defined, used to model system calls
\end{itemize}
there are more - see p. 2-7 of Mechanized Sem. for details. (TODO)
  
  \end{frame}
\begin{frame}
  
  Limitations

  Partial correctness (safety? liveness?)
  
  \end{frame}

  \section{Operational semantics: bigstep}

  
  \begin{frame}

     Our goal is to prove that programs written in C light behave as intented. To do this we need to formalize the notion of meaning of a C light program. We do this using what is called operational semantics. We start from assigning primitive values to constants and then compositionally assign values to expressions and statement. 
      
   \end{frame}

   \begin{frame}
    
- final result of a program execution
- trace of invocation of external functions
- deterministic (since expressions are pure)

Evaluation done in a context with global vars (G), local vars (E) and memory state (M). Rules described in Fig.6-10. of Mech Sem
    \end{frame}

  \begin{frame}
    A CompCert C value is either\footnote{This is a common semantics used for all intermediate languages of CompCert, such as C minor etc.}:
    \begin{itemize}
    
\item a machine integer;
\item a floating-point number;
\item a pointer: a pair of a memory address and an integer offset with respect
  to this address;
\item the \texttt{Vundef} value denoting an arbitrary bit pattern, such as the
  value of an uninitialized variable.
 \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Values}
  
\begin{lstlisting}[language=Coq]

  Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.
\end{lstlisting}

\begin{itemize}
\item \texttt{float} type is formalized in Flocq library
\item \texttt{int} and \texttt{ptrofs} types are defined in CompCert 
\end{itemize}
  
\end{frame}  


\begin{frame}[t,fragile]{Integers}

Formalizations of machine integers modulo $2^N$ defined as a module type in CompCert \url{lib/Integers.v}.\\

\bigskip

A machine integer (type \texttt{int}) is represented as a Coq arbitrary-precision
integer (type \texttt{Z} ) plus a proof that it is in the range 0 (included) to
modulus (excluded).

\bigskip

\begin{lstlisting}[language=Coq]
Record int: Type :=
mkint { intval: Z; intrange: -1 < intval < modulus }.
\end{lstlisting}

8, 32, 64-bit integers are supported, as well as 32 and 64-bit pointer offsets.

\end{frame}

\begin{frame}[t,fragile]{Integers}

 Integer is basically a natural number with a bound, thus we can prove an induction principle for integers

\bigskip

\begin{lstlisting}[language=Coq]
  Lemma int_induction :
  forall (P : int -> Prop), P Int.zero ->
       (forall i, P i -> P (Int.add i Int.one)) ->
             forall i, P i.
\end{lstlisting}

 \begin{proof}

   By using induction principle for non-negative integers \texttt{natlike\_ind} for \texttt{Z}.
                                       
 \end{proof}



\end{frame}




\begin{frame}{Memory model}
defined in CompCert \url{common/Memory.v}

\bigskip
a type \texttt{mem} of memory states, the following 4 basic
operations over memory states, and their properties:
\begin{itemize}
\item [load]: read a memory chunk at a given address;
\item [store]: store a memory chunk at a given address;
\item [alloc]: allocate a fresh memory block;
\item [free]: invalidate a memory block.
\end{itemize}
\end{frame}

  
\begin{frame}{C light semantics}
We define evaluation relation between statements of C light and CompCert C values 
\end{frame}


\section{Toy example: length of a C string}

\begin{frame}{Informal spec: strlen}

  The GNU C Reference Manual:
 \bigskip


  $\ldots$ A string constant is of type ``array of characters''. All string constants contain a null termination character as their last character.

\bigskip

$\ldots$
DESCRIPTION        

 The strlen() function calculates the length of the string pointed to
 by s, excluding the terminating null byte.

 \bigskip

RETURN VALUE 

 The strlen() function returns the number of bytes in the string
 pointed to by s.

 \bigskip

CONFORMING TO 

 POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD.



\end{frame}

\begin{frame}
 To formalize the spec we need a formal model of C integers, pointers and memory model
\end{frame}

\begin{frame}[t,fragile]{Formal spec}

  \begin{lstlisting}[language=Coq]
    
Inductive strlen (m : mem) (b : block) (ofs : ptrofs) : int -> Prop :=
  | LengthZero: load m [b,ofs] = Some 0 -> strlen m b ofs 0
  | LengthSucc: forall (n : int) (c : char),
                      strlen m b ofs + 1 n ->
                      load m [b,ofs] = Vint c ->
                      c <> Int.zero ->
                      n + 1 <= MaxInteger ->
                      strlen m b ofs n + 1.
  \end{lstlisting}
  
  
  
      
\end{frame}

\begin{frame}{From C program to AST using clightgen}

\lstinputlisting[language=C]{strlen.c}

\end{frame}

\begin{frame}[fragile]{C light AST (loop of strlen)}

\begin{lstlisting}[language=Coq]
Definition f_strlen_loop := {|
fn_params := ((_s, (tptr tuchar)) :: nil);
fn_temps := ((_i, tuint) :: (_t1, (tptr tuchar)) :: (_t2, tuchar) :: nil);
fn_body := 
(Sloop
(Ssequence
(Ssequence
(Ssequence
  (Sset _t1 (Etempvar _s (tptr tuchar)))
  (Sset _s
    (Ebinop Oadd (Etempvar _t1 (tptr tuchar))
      (Econst_int (Int.repr 1) tint) (tptr tuchar))))
(Ssequence
  (Sset _t2 (Ederef (Etempvar _t1 (tptr tuchar)) tuchar))
  (Sifthenelse (Etempvar _t2 tuchar) Sskip Sbreak)))
(Sset _i
(Ebinop Oadd (Etempvar _i tuint) (Econst_int (Int.repr 1)
 tint)
  tuint)))
Sskip) |}.

\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Correctness}

  We prove that for all strings our program computes correct result. In particular:
  
  \begin{theorem}
    For all addresses $[b, ofs]$ where a valid C string of length $len$ is stored, the C light AST $f\_strlen$ evaluates to $len$.
  \end{theorem}
  
  
  \begin{lstlisting}[language=Coq]
Lemma strlen_correct:
forall len m b ofs le, strlen m b ofs len -> exists t l',
  le!_input = Some (Vptr b ofs) ->
  exec_stmt le m f_strlen t le' m (Out_return (Some (Vint len))).

\end{lstlisting}

To prove this statement we have to prove that loop works correctly.

 



\end{frame}

  
\begin{frame}[fragile]{Correctness cont'd}

  
  
  \begin{lstlisting}[language=Coq]
 Lemma strlen_loop_correct: forall len m b ofs le,
 strlen m b ofs len -> exists t le',
 le!_output = Some (Vint 0) ->
 le!_input = Some (Vptr b ofs) ->
 exec_stmt ge e le m f_strlen_loop t le' m Out_normal
                     /\ le'!_output = Some (Vint len).
\end{lstlisting}

\begin{proof}
  We prove a generalization of this statement
  
 \begin{lstlisting}[language=Coq]
 Lemma strlen_loop_correct_gen : forall len m b ofs le,
 strlen m b ofs + i len -> exists t le',
 le!_output = Some (Vint i) ->
 le!_input = Some (Vptr b ofs + i) ->
 exec_stmt ge e le m f_strlen_loop t le' m Out_normal
                     /\ le'!_output = Some (Vint len + i).
\end{lstlisting}

by \texttt{int}-induction on $len$ and $i$. 

  \end{proof}

 



\end{frame}

\begin{frame}{Conclusion}
  Thus we have proved that on all strings of length smaller than
  \texttt{UINT\_MAX}, \texttt{strlen} works correctly.
  
  \end{frame}


\end{document}