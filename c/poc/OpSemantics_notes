An operational semantics is a mathematical model of programming language execution. It is, in essence, an interpreter defined mathematically.
Anoperational semanticsfor a program-ming language is a mathematical definition of its computation relation,e)v, whereeis a program in the language
e)vis mathematically a 2-place relation between expressions of the language,e, andvalues of the language,v. Integers and booleans are values.
An operational semantics for a programming language is a means for understanding inprecise detail the meaning of an expression in the language
It is the formal specificationof the language that is used when writing compilers and interpreters, and it allows us torigorously verify things about the language.

Operational semantics rules discuss how pieces of code evaluate


Correctness:

The kinds of semantics we have seen so far specify the meaning of programs,
although they may also be used to prove that given programs possess cer-
tain properties. We may distinguish among several classes of properties: partial
correctness properties are properties expressing that if a given program termi-
nates, then there will be a certain relationship between the initial and the final
values of the variables. Thus a partial correctness property of a program need
not ensure that it terminates. This is contrary to total correctness properties,
which express that the program will terminate and that there will be a certain
relationship between the initial and the final values of the variables. Thus we
have
partial correctness + termination = total correctness

Big-step semantics only tells us something about the behavior of terminating
 * programs.

Full functional verification vresus partial verification

functional CorrectnessTo  verify  a  system’s  functional  cor-rectness   requires   formally   proving   that  all  possible  system  runs  satisfy  a  declarative  specification  of  the  sys-tem’s  externally  observable  behavior.  The system must satisfy the specifica-tion for all possible inputs and initial system states.The  standard  approach  is  to  use  contract-based  specifications.  If  the  input  and  the  initial  state,  in  which  the  system  is  started,  satisfy  a  given  precondition,  then  the  system’s  final  state  must  satisfy  a  given  postcon-dition,  such  as,  “If  the  input  is  non-  negative, then the output is the square root  of  the  input.”


Verification MethodsMost  verification  approaches  fall  into  one  of  four  methodologies:  deductive  verification, model checking, refinement and code generation, and abstract inter-pretation.


SeL4 has guard checks at parsing:

But we can try parsing a very simple C file with SeL4's parser:

int add(int a, int b) {
  return a+b;
}

That fits SeL4's C subset (called StrictC - see l4v/tools/c-parser/doc in the SeL4 source) and results in this Simpl construct (you'll need to read the Simpl paper to really understand it):

test_global_addresses.add_body ≡
TRY
  Guard SignedArithmetic ⦃-2147483648 ≤ sint ´a + sint ´b ∧ sint ´a + sint ´b ≤ 2147483647⦄
   (creturn global_exn_var_'_update ret__int_'_update (λs. a_' s + b_' s));;
  Guard DontReach {} SKIP
CATCH SKIP
END

difference with other FV techniques:

The central piece of this work is still the initial functional correctness verificationof seL4 [Klein et al. 2009b] in the theorem prover Isabelle/HOL [Nipkow et al. 2002].This property is stronger and more precise than what automated techniques such asmodel checking, static analysis or kernel implementations in type-safe languages canachieve. It not only analyses specific aspects of the kernel, such as safe execution, butalso provides a full specification and proof for the kernel’s precise behaviour down toits C implementation on the ARM platform.

While the Haskell prototype is an executable model and an implementation of thefinal design, it is not the final production kernel. As shown in Figure 2, we manuallyre-implemented the model in the C programming language. We did this for severalreasons. First, the Haskell runtime is a significant body of code (much bigger than ourkernel) which would be hard to verify for correctness. Second, the Haskell runtimerelies on garbage collection which is unsuitable for real-time environments. Inciden-tally, the same arguments apply to other systems based on type-safe languages, suchas SPIN [Bershad et al. 1995] and Singularity [F ̈ahndrich et al. 2006]. Additionally,using C enables optimisation of the low-level implementation for performance. Whilean  automated  translation  from  Haskell  to  C  would  have  simplified  verification,  wewould have lost most opportunities to micro-optimise the kernel, which we considernecessary for adequate microkernel performance.After design and prototyping led to stabilised versions of executable and abstractspecification, verification between these could commence, and the C code could be im-plemented concurrently. Eventually, when the process finishes, both specifications andC code are linked by proof. The original Haskell prototype is not part of the proof chain.

These results together constitute a functional correctness property in the strongestsense. Formally, we are showingrefinement[de Roever and Engelhardt 1998]: A re-finement proof establishes a correspondence between a high-level (abstract) and a low-level (concrete, orrefined) representation of a system.

The correspondence established by the refinement proof ensures that all Hoare logicproperties of the abstract model also hold for the refined model. This means that if asecurity property is proved in Hoare logic about the abstract model (not all securityproperties can be), refinement gives us an end-to-end theorem in Isabelle/HOL thatthe same property holds for the kernel source code. The binary verification establishesanother refinement theorem, this time between the source code and the binary, albeitin a separate tool

We have proved that the executable specification of the kernel correctly implementsthe  abstract  specification.  With  its  extreme  level  of  detail,  this  proof  alone  alreadyprovides strong design assurance. It concentrates the highest level of manual workand creativity in the overall verification. It also already contains of the order of 90% ofthe invariants that we have proved about the kernel